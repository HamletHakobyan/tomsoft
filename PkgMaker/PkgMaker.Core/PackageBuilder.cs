using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using ICSharpCode.SharpZipLib.Zip;
using PkgMaker.Core;

namespace PkgMaker.Core
{
    public class PackageBuilder
    {
        public void BuildPackage(Package pkg, string basePath)
        {
            Trace.WriteLine(string.Empty);
            Trace.TraceInformation("*** Building package '{0}'", pkg.ExpandProperties(pkg.Name));

            string sourceBasePath = PathUtil.GetFullPath(basePath, pkg.ExpandProperties(pkg.SourceBasePath));

            Trace.TraceInformation("Populating package content...");

            var packageEntries = new List<PackageEntry>();
            PopulateEntries(pkg, sourceBasePath, packageEntries);

            int nDirectories = 0;
            int nFiles = 0;
            Func<PackageEntry, bool> counter =
                e =>
                {
                    if (e.IsDirectory) nDirectories++;
                    else nFiles++;
                    return true;
                };

            var entries = packageEntries.TakeWhile(counter).OrderBy(e => e.EntryName).ToList();

            Trace.TraceInformation("Found {0} directories and {1} files", nDirectories, nFiles);
            if (CreateFileList)
            {
                WriteFileList(pkg, basePath, entries);
            }

            Trace.TraceInformation("Building archive...");

            BuildArchive(pkg, basePath, entries);

            Trace.TraceInformation("Complete !");
        }

        private void BuildArchive(Package pkg, string basePath, List<PackageEntry> entries)
        {
            string outputFileName = pkg.ExpandProperties(pkg.OutputFileName);
            string outputDir = Path.GetDirectoryName(outputFileName);
            Directory.CreateDirectory(outputDir);
            string zipFileName = Path.Combine(basePath, outputFileName);
            using (var zipFile = ZipFile.Create(zipFileName))
            {
                zipFile.BeginUpdate();
                foreach (var entry in entries)
                {
                    if (entry.IsDirectory)
                    {
                        zipFile.AddDirectory(entry.EntryName);
                    }
                    else
                    {
                        zipFile.Add(entry.SourcePath, entry.EntryName);
                    }
                }

                StringBuilder comment = new StringBuilder();
                if (!pkg.Name.IsNullOrEmpty())
                    comment.AppendLine(pkg.ExpandProperties(pkg.Name));
                if (!pkg.Version.IsNullOrEmpty())
                    comment.AppendLine("Version: " + pkg.ExpandProperties(pkg.Version));
                if (!pkg.Description.IsNullOrEmpty())
                    comment.AppendLine(pkg.ExpandProperties(pkg.Description));
                comment.AppendLine("Package generated by PkgMaker");
                zipFile.SetComment(comment.ToString());

                zipFile.CommitUpdate();
            }
        }

        private void WriteFileList(Package pkg, string basePath, List<PackageEntry> entries)
        {
            string outputFileName = pkg.ExpandProperties(pkg.OutputFileName);
            string outputPath = Path.GetDirectoryName(PathUtil.GetFullPath(basePath, outputFileName));
            string baseFileName = Path.GetFileNameWithoutExtension(outputFileName);
            string fileListPath = Path.Combine(outputPath, baseFileName + "_FileList.txt");
            using (var writer = new StreamWriter(fileListPath))
            {
                foreach (var entry in entries)
                {
                    writer.WriteLine("{0}\t\t{1}",
                        entry.IsDirectory ? "DIR" : "   ",
                        entry.EntryName);
                }
            }
            Trace.TraceInformation("File list stored in {0}", fileListPath);
        }

        private void PopulateEntries(Package pkg, string sourceBasePath, List<PackageEntry> entries)
        {
            PopulateEntries(pkg.Root, string.Empty, sourceBasePath, entries, pkg.Properties);
        }

        private void PopulateEntries(PackageDirectory directory, string parentEntryName, string sourceBasePath, List<PackageEntry> entries, PackageProperties properties)
        {
            string name = properties.Expand(directory.Name);
            string dirEntryName = Path.Combine(parentEntryName, name ?? string.Empty);

            if (!name.IsNullOrEmpty())
            {
                entries.Add(new PackageEntry
                {
                    EntryName = dirEntryName,
                    IsDirectory = true
                });
            }

            // Populate includes
            foreach (var include in directory.Includes)
            {
                PopulateEntries(include.Directory, dirEntryName, sourceBasePath, entries, properties);
            }


            // Populate sources
            foreach (var source in directory.Sources)
            {
                if (source is FileSource)
                {
                    var fileSource = (FileSource)source;
                    string filePath = properties.Expand(fileSource.Path);
                    string entryName = Path.Combine(dirEntryName, Path.GetFileName(filePath));
                    string fileName = PathUtil.GetFullPath(sourceBasePath, filePath);

                    entries.Add(new PackageEntry
                    {
                        EntryName = entryName,
                        SourcePath = fileName,
                        IsDirectory = false
                    });
                }
                else if (source is DirectorySource)
                {
                    var directorySource = (DirectorySource)source;
                    string directoryPath = properties.Expand(directorySource.Path);
                    var fullPath = PathUtil.GetFullPath(sourceBasePath, directoryPath);
                    var dirInfo = new DirectoryInfo(fullPath);
                    var queue = new Queue<FileSystemInfo>(dirInfo.EnumerateFileSystemInfos());
                    while (queue.Count > 0)
                    {
                        var item = queue.Dequeue();
                        var di = item as DirectoryInfo;
                        bool isDirectory = (di != null);
                        if (isDirectory && !directorySource.Recursive)
                            continue;

                        if (IncludeItem(item, fullPath, directorySource.Exclusions, properties))
                        {
                            string relativePath = PathUtil.GetRelativePath(fullPath, item.FullName);
                            string entryName = Path.Combine(dirEntryName, relativePath);
                            entries.Add(new PackageEntry
                            {
                                EntryName = entryName,
                                SourcePath = item.FullName,
                                IsDirectory = isDirectory
                            });

                            if (isDirectory)
                            {
                                foreach (var fsi in di.EnumerateFileSystemInfos())
                                {
                                    queue.Enqueue(fsi);
                                }
                            }
                        }
                    }
                }
            }

            // Populate subdirectories
            foreach (var subDirectory in directory.SubDirectories)
            {
                PopulateEntries(subDirectory, dirEntryName, sourceBasePath, entries, properties);
            }
        }

        private bool IncludeItem(FileSystemInfo item, string basePath, IEnumerable<ExclusionBase> exclusions, PackageProperties properties)
        {
            return !exclusions.Any(e => e.IsMatch(item, basePath, properties));
        }

        private class PackageEntry
        {
            public string SourcePath { get; set; }
            public string EntryName { get; set; }
            public bool IsDirectory { get; set; }
        }

        public bool CreateFileList { get; set; }
    }
}
