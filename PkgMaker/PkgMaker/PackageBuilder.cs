using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Developpez.Dotnet;
using Developpez.Dotnet.Collections;
using ICSharpCode.SharpZipLib.Zip;
using PkgMaker.Model;

namespace PkgMaker
{
    public class PackageBuilder
    {
        public void BuildPackage(Package pkg, string basePath)
        {
            Trace.WriteLine(string.Empty);
            Trace.TraceInformation("*** Building package '{0}'", pkg.Name);

            string sourceBasePath = PathUtil.GetFullPath(basePath, pkg.SourceBasePath);

            Trace.TraceInformation("Populating package content...");

            var packageEntries = new List<PackageEntry>();
            PopulateEntries(pkg, sourceBasePath, packageEntries);

            int nDirectories = 0;
            int nFiles = 0;
            Action<PackageEntry> counter =
                e =>
                {
                    if (e.IsDirectory) nDirectories++;
                    else nFiles++;
                };

            var entries = packageEntries.Apply(counter).OrderBy(e => e.EntryName).ToList();

            string fileListPath = WriteFileList(pkg, basePath, entries);

            Trace.TraceInformation("Found {0} directories and {1} files", nDirectories, nFiles);
            Trace.TraceInformation("File list stored in {0}", fileListPath);

            Trace.TraceInformation("Building archive...");

            BuildArchive(pkg, basePath, entries);

            Trace.TraceInformation("Complete !");
        }

        private void BuildArchive(Package pkg, string basePath, List<PackageEntry> entries)
        {
            string zipFileName = Path.Combine(basePath, pkg.OutputFileName);
            using (var zipFile = ZipFile.Create(zipFileName))
            {
                zipFile.BeginUpdate();
                foreach (var entry in entries)
                {
                    if (entry.IsDirectory)
                    {
                        zipFile.AddDirectory(entry.EntryName);
                    }
                    else
                    {
                        zipFile.Add(entry.SourcePath, entry.EntryName);
                    }
                }

                StringBuilder comment = new StringBuilder();
                if (!pkg.Name.IsNullOrEmpty())
                    comment.AppendLine(pkg.Name);
                if (!pkg.Version.IsNullOrEmpty())
                    comment.AppendLine("Version: " + pkg.Version);
                if (!pkg.Description.IsNullOrEmpty())
                    comment.AppendLine(pkg.Description);
                comment.AppendLine("Package generated by PkgMaker");
                zipFile.SetComment(comment.ToString());

                zipFile.CommitUpdate();
            }
        }

        private string WriteFileList(Package pkg, string basePath, List<PackageEntry> entries)
        {
            string outputPath = Path.GetDirectoryName(PathUtil.GetFullPath(basePath, pkg.OutputFileName));
            string baseFileName = Path.GetFileNameWithoutExtension(pkg.OutputFileName);
            string fileListPath = Path.Combine(outputPath, baseFileName + "_FileList.txt");
            using (var writer = new StreamWriter(fileListPath))
            {
                foreach (var entry in entries)
                {
                    writer.WriteLine("{0}\t\t{1}",
                        entry.IsDirectory ? "DIR" : "   ",
                        entry.EntryName);
                }
            }
            return fileListPath;
        }

        private void PopulateEntries(Package pkg, string sourceBasePath, List<PackageEntry> entries)
        {
            PopulateEntries(pkg.Root, string.Empty, sourceBasePath, entries);
        }

        private void PopulateEntries(PackageDirectory directory, string parentEntryName, string sourceBasePath, List<PackageEntry> entries)
        {
            string dirEntryName = Path.Combine(parentEntryName, directory.Name ?? string.Empty);

            if (!directory.Name.IsNullOrEmpty())
            {
                entries.Add(new PackageEntry
                {
                    EntryName = dirEntryName,
                    IsDirectory = true
                });
            }

            // Populate includes
            foreach (var include in directory.Includes)
            {
                PopulateEntries(include.Directory, dirEntryName, sourceBasePath, entries);
            }


            // Populate sources
            foreach (var source in directory.Sources)
            {
                if (source is FileSource)
                {
                    var fileSource = (FileSource)source;
                    string entryName = Path.Combine(dirEntryName, Path.GetFileName(fileSource.Path));
                    string fileName = PathUtil.GetFullPath(sourceBasePath, fileSource.Path);

                    entries.Add(new PackageEntry
                    {
                        EntryName = entryName,
                        SourcePath = fileName,
                        IsDirectory = false
                    });
                }
                else if (source is DirectorySource)
                {
                    var directorySource = (DirectorySource)source;
                    var fullPath = PathUtil.GetFullPath(sourceBasePath, directorySource.Path);
                    var dirInfo = new DirectoryInfo(fullPath);
                    var queue = new Queue<FileSystemInfo>(dirInfo.EnumerateFileSystemInfos());
                    while (queue.Count > 0)
                    {
                        var item = queue.Dequeue();
                        var di = item as DirectoryInfo;
                        bool isDirectory = (di != null);
                        if (isDirectory && !directorySource.Recursive)
                            continue;

                        if (IncludeItem(item, fullPath, directorySource.Exclusions))
                        {
                            string relativePath = PathUtil.GetRelativePath(fullPath, item.FullName);
                            string entryName = Path.Combine(dirEntryName, relativePath);
                            entries.Add(new PackageEntry
                            {
                                EntryName = entryName,
                                SourcePath = item.FullName,
                                IsDirectory = isDirectory
                            });

                            if (isDirectory)
                            {
                                foreach (var fsi in di.EnumerateFileSystemInfos())
                                {
                                    queue.Enqueue(fsi);
                                }
                            }
                        }
                    }
                }
            }

            // Populate subdirectories
            foreach (var subDirectory in directory.SubDirectories)
            {
                PopulateEntries(subDirectory, dirEntryName, sourceBasePath, entries);
            }
        }

        private bool IncludeItem(FileSystemInfo item, string basePath, IEnumerable<ExclusionBase> exclusions)
        {
            foreach (var exclusion in exclusions)
            {
                if (IsMatch(item, basePath, exclusion))
                    return false;
            }
            return true;
        }

        private bool IsMatch(FileSystemInfo item, string basePath, ExclusionBase exclusion)
        {
            if (exclusion is FileSystemEntryExclusion)
                return IsMatch(item, basePath, (FileSystemEntryExclusion)exclusion);
            if (exclusion is ExtensionExclusion)
                return IsMatch(item, basePath, (ExtensionExclusion)exclusion);
            if (exclusion is PatternExclusion)
                return IsMatch(item, basePath, (PatternExclusion)exclusion);

            Trace.TraceWarning("{0} is not a known exclusion type", exclusion.GetType());
            return false;
        }

        private bool IsMatch(FileSystemInfo item, string basePath, FileSystemEntryExclusion exclusion)
        {
            if (exclusion.Directory == (item is DirectoryInfo))
            {
                string relativePath = exclusion.Any ? item.Name : PathUtil.GetRelativePath(basePath, item.FullName);
                return relativePath.Equals(exclusion.Path.TrimEnd('\\'), StringComparison.CurrentCultureIgnoreCase);
            }
            return false;
        }

        private bool IsMatch(FileSystemInfo item, string basePath, ExtensionExclusion exclusion)
        {
            if (item is FileInfo)
            {
                string extension = ((FileInfo)item).Extension.TrimStart('.');
                return extension.Equals(exclusion.Extension.TrimStart('.'), StringComparison.CurrentCultureIgnoreCase);
            }
            return false;
        }

        private bool IsMatch(FileSystemInfo item, string basePath, PatternExclusion exclusion)
        {
            string relativePath = PathUtil.GetRelativePath(basePath, item.FullName);
            return Regex.IsMatch(relativePath, exclusion.Pattern, RegexOptions.IgnoreCase);
        }

        private class PackageEntry
        {
            public string SourcePath { get; set; }
            public string EntryName { get; set; }
            public bool IsDirectory { get; set; }
        }
    }
}
